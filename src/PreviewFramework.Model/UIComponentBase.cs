using System;
using System.Collections.Generic;
using System.Linq;

namespace PreviewFramework.Model;

public abstract class UIComponentBase<TPreview>(UIComponentKind kind, string? displayNameOverride, IReadOnlyList<TPreview> previews) where TPreview : PreviewBase
{
    private readonly IReadOnlyList<TPreview> _previews = previews;

    /// <summary>
    /// Name is intended to be what's used by the code to identify the component. It's the component's
    /// full qualified type name and is unique.
    /// </summary>
    public abstract string Name { get; }

    public UIComponentCategory? Category { get; private set; }

    public UIComponentKind Kind { get; } = kind;

    /// <summary>
    /// DisplayName is intended to be what's shown in the UI to identify the component. It can contain spaces and
    /// isn't necessarily unique. It defaults to the class name (with no namespace qualifier) but can be
    /// overridden by the developer.
    /// </summary>
    public string DisplayName => DisplayNameOverride ?? NameUtilities.GetUnqualifiedName(Name);

    public string? DisplayNameOverride { get; } = displayNameOverride;

    public bool HasPreview => _previews.Count >= 0;

    public bool HasNoPreviews => _previews.Count == 0;

    public bool HasSinglePreview => _previews.Count == 1;

    public bool HasMultiplePreviews => _previews.Count > 1;

    public IReadOnlyList<TPreview> Previews => _previews;

    public TPreview? GetPreview(string name)
    {
        foreach (TPreview preview in _previews)
        {
            if (preview.Name.Equals(name, StringComparison.Ordinal))
            {
                return preview;
            }
        }

        return null;
    }

    public TPreview DefaultPreview
    {
        get
        {
            if (_previews.Count == 0)
            {
                throw new InvalidOperationException($"Component '{Name}' has no previews");
            }

            // Currently, the default preview is always the first one, though we may allow
            // it to be set explicitly in the future
            return _previews[0];
        }
    }

    /// <summary>
    /// Creates a copy of this UI component with an additional preview.
    /// If the new preview is not auto-generated, removes any auto-generated previews from the result.
    /// </summary>
    /// <param name="preview">The preview to add</param>
    /// <returns>A new UI component instance with the added preview</returns>
    public abstract UIComponentBase<TPreview> WithAddedPreview(TPreview preview);

    public bool IsAutoGenerated => _previews.All(e => e.IsAutoGenerated);

    /// <summary>
    /// Helper method for subclasses to apply the auto-generated preview removal logic for WithAddedPreview.
    /// </summary>
    protected IReadOnlyList<TPreview> GetUpdatedPreviews(TPreview newPreview)
    {
        List<TPreview> updatedPreviews = _previews.ToList();
        updatedPreviews.Add(newPreview);

        // If there's a user defined preview, remove any auto-generated previews
        if (!newPreview.IsAutoGenerated)
        {
            updatedPreviews.RemoveAll(e => e.IsAutoGenerated);
        }

        return updatedPreviews;
    }
}
